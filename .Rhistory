"Swaziland", "Ghana", "Haiti", "Honduras", "India", "Indonesia",
"Iran", "Kenya", "Kiribati", "Kyrgyztan", "Laos", "Lebanon",
"Lesotho", "Mauritania", "Micronesia", "Mongolia", "Morocco",
"Myanmar", "Nepal", "Nicaragua", "Nigeria", "Pakistan",
"Papua New Guinea", "Philippines", "Samoa", "Sao Tome and Principe",
"Senegal", "Solomon Islands", "Sri Lanka", "Tajikistan", "Tanzania",
"Timor-Leste", "Tunisia", "Ukraine", "Uzbekistan", "Vanuatu",
"Vietnam", "Palestina", "Zimbabwe")
countries_up_mid_income <- c("Albania", "Armenia", "American Samoa", "Argentina", "Azerbaijan",
"Belarus", "Belize", "Bosnia and Herzegovina", "Botswana",
"Brazil", "Bulgaria", "China", "Colombia", "Costa Rica", "Cuba",
"Dominica", "Dominican Republic", "Ecuador", "Equatorial Guinea",
"Fiji", "Gabon", "Georgia", "Grenada", "Guatemala", "Guyana",
"Iraq", "Jamaica", "Jordan", "Kazakhstan", "Kosovo", "Libya",
"Malaysia", "Maldives", "Marshall Islands", "Mauritius", "Mexico",
"Moldova", "Montenegro", "Namibia", "North Macedonia", "Palau",
"Paraguay", "Peru", "Russia", "Serbia", "South Africa", "St. Lucia",
"Saint Vincent and the Grenadines", "Suriname", "Thailand", "Tonga",
"Turkey", "Turkmenistan", "Tuvalu", "Venezuela")
countries_high_income <- c("Andorra", "Antigua and Barbuda", "Aruba", "Australia", "Austria",
"Bahamas", "Bahrain", "Barbados", "Belgium", "Bermuda", "British Virgin Islands",
"Brunei", "Canada", "Cayman Islands", "Channel Islands", "Chile", "Croatia",
"Curacao", "Cyprus", "Czech Republic", "Denmark", "Estonia", "Faroe Islands", "Finland",
"France", "French Polynesia", "Germany", "Gibraltar", "Greece", "Greenland",
"Guam", "Hong Kong", "Hungary", "Iceland", "Ireland", "Isle of Man", "Israel",
"Italy", "Japan", "Korea, Rep.", "Kuwait", "Latvia", "Liechtenstein",
"Lithuania", "Luxembourg", "Macao", "Malta", "Monaco", "Nauru", "Netherlands",
"New Caledonia", "New Zealand", "Northern Mariana Islands", "Norway", "Oman",
"Panama", "Poland", "Portugal", "Puerto Rico", "Qatar", "Romania", "San Marino",
"Saudi Arabia", "Seychelles", "Singapore", "Sint Marteen", "Slovakia", "Slovenia",
"Spain", "Saint Kitts and Nevis", "Saint Martin", "Sweden", "Switzerland",
"Trinidad and Tobago", "Turks and Caicos Islands", "United Arab Emirates",
"United Kingdom", "United States", "Uruguay", "Virgin Islands U.S.")
## load world map data
world <- map_data("world")
world$region[which(world$region == "USA")] <- "United States"
world$region[which(world$region == "UK")] <- "United Kingdom"
world$region[which(world$region == "Ivory Coast")] <- "Cote d'Ivoire"
#-------------------------------------------------------------------------------
## Get data set that corresponds to that used in regressions
#-------------------------------------------------------------------------------
data_descript <- data[which(!is.na(data$cpi) &
!is.na(data$trade_openness) &
!is.na(data$pop_dens_log) &
!is.na(data$demeaned_winning) &
!is.na(data$industry_share) &
!is.na(data$top10)),]
#-------------------------------------------------------------------------------
## Summary stats
#-------------------------------------------------------------------------------
# options("modelsummary_format_numeric_latex" = "plain")
#
# datasummary(formula = (`PM$_2.5$ (orig. scale)` = PM25_pop_weighed) + (`PM$_2.5$ (log scale)` = lead_log_PM25) +
#                       (`Top 10%-share` = top10) + (`Top 1%-share` = top1) + (`Bottom 50%-share` = bottom50) +
#                       (`T10/B50-ratio` = t10b50ratio) + (`log(GDP per capita)$^2$` = `2_gdp_pc_log`) +
#                       (`W/S-ratio` = W4) + (`Trade openness` = trade_openness) + (`Corruption`= cpi) +
#                       (`Industry (% GDP)` = industry_share) + (`log(Pop. density)`= pop_dens_log) + (`Year`= year) +
#                       (`Polyarchy`= v2x_polyarchy)  + (`GDP per cap. growth` = gdp_pc_growth) +
#                       (`GDP per cap/km$^2$`= gdp_pc_sqkm) + (`Average temp.`= Annual_temp) +
#                       (`Precip. variab.` = precip_var) + (`Urban pop. (%)` = urban_pop)
#                       ~ N + Mean + SD + Min + Median + Max,
#             data = data_descript,
#             output = "latex")
#-------------------------------------------------------------------------------
## Differentiate inequality increasing / decreasing countries over time
#-------------------------------------------------------------------------------
## create lead variable
data_trend <- data %>%
group_by(country) %>%
arrange(year)%>%
mutate(lead_top10 = dplyr::lead(top10),
lead_PM25 = dplyr::lead(PM25_pop_weighed))
## name columns
data_trend <- data_trend[,c("country", "year", "top10", "lead_top10",
"PM25_pop_weighed", "lead_PM25")]
## add inequality trend column
data_trend$trend_ineq <- NA
## get variable that indicates increase vs. decrease in t+1 compared to t
for(i in 1:nrow(data_trend)){
data_trend$trend_ineq[i] <- ifelse((!is.na(data_trend$lead_top10[i]) & !is.na(data_trend$top10[i])),    # if both top10 and lead top10 not NA
(data_trend$lead_top10[i] - data_trend$top10[i]), NA)                # insert diff between them
}
## get overall trend (more increasing vs. more decreasing years)
summary_trend_ineq <- data_trend %>%
group_by(country) %>%
summarize(sum_trend_ineq = ifelse(all(is.na(trend_ineq)), NA, sum(trend_ineq, na.rm = TRUE)),
var_trend_ineq = ifelse(all(is.na(trend_ineq)), NA, var(trend_ineq, na.rm = TRUE)))
## colnames
colnames(summary_trend_ineq)[1:3] <- c("country", "trend_ineq", "var_trend_ineq")
## combine
data <- left_join(data, summary_trend_ineq, by = "country")
summary(data$trend_ineq)
summary(data$var_trend_ineq)
## clean up
remove(data_trend)
#-------------------------------------------------------------------------------
# Plot trend variable
#-------------------------------------------------------------------------------
min_diff <- round(min(data$trend_ineq, na.rm = TRUE), digits = 2)
max_diff <- round(max(data$trend_ineq, na.rm = TRUE), digits = 2)
pdf("plots/Trend_inequality.pdf")
ggplot(data[which(!is.na(data$trend_ineq)),],
aes(x = reorder(country, trend_ineq), y = trend_ineq, fill = trend_ineq >= 0)) +
theme_classic() +
geom_bar(stat = "identity") +
labs(y = "Change in Top 10%-share", x = "Countries") +
scale_fill_manual(name = NULL,
breaks = c("TRUE", "FALSE"),
labels = c("Increase", "Decrease"),
values = c(viridis(3)[2],
viridis(3)[1])) +
theme(axis.text.x = element_blank(),
axis.text.y = element_text(size = 3),
axis.ticks.y = element_blank(),
axis.ticks.x = element_blank(),
axis.title = element_text(size = 12),
legend.position = "bottom",
legend.text = element_text(size = 10)) +
annotate("text", x = 168, y = 3.7, label = "Max (India) \n+0.17", size = 3.2) +
annotate("text", x = 10, y = -4, label = "Min (Maldives) \n-0.18", size = 3.2) +
coord_flip()
dev.off()
#-------------------------------------------------------------------------------
# Plot variation
#-------------------------------------------------------------------------------
pdf("plots/Trend_inequality_var.pdf")
ggplot(data[which(!is.na(data$var_trend_ineq)),],
aes(x = reorder(country, var_trend_ineq), y = var_trend_ineq, fill = var_trend_ineq)) +
theme_classic() +
geom_bar(stat = "identity") +
labs(y = "Variance of Top 10%-share", x = "Countries") +
scale_fill_gradient(low = viridis(1, alpha = 0.5),
high = viridis(1, alpha = 1),
na.value = "grey50",
guide = "colourbar",
aesthetics = "fill") +
theme(axis.text.x = element_text(size = 10),
axis.text.y = element_text(size = 3),
axis.ticks.y = element_blank(),
axis.title = element_text(size = 12),
legend.position = "none",
legend.text = element_text(size = 10)) +
annotate("text", x = 172, y = 0.026, label = "Max (Singapore)", size = 3.2) +
coord_flip()
dev.off()
ggplot(data[which(!is.na(data$trend_ineq)),],
aes(x = reorder(country, trend_ineq), y = trend_ineq, fill = trend_ineq >= 0)) +
theme_classic() +
geom_bar(stat = "identity") +
labs(y = "Change in Top 10%-share", x = "Countries") +
scale_fill_manual(name = NULL,
breaks = c("TRUE", "FALSE"),
labels = c("Increase", "Decrease"),
values = c(viridis(3)[2],
viridis(3)[1])) +
theme(axis.text.x = element_blank(),
axis.text.y = element_text(size = 3),
axis.ticks.y = element_blank(),
axis.ticks.x = element_blank(),
axis.title = element_text(size = 12),
legend.position = "bottom",
legend.text = element_text(size = 10)) +
annotate("text", x = 168, y = 3.7, label = "Max (India) \n+0.17", size = 3.2) +
annotate("text", x = 10, y = -4, label = "Min (Maldives) \n-0.18", size = 3.2) +
coord_flip()
m1_re_wb_fe <- lm(lead_log_PM25 ~ top10 +
`2_gdp_pc_log` + `2_gdp_pc_log_sq` + W4 +
trade_openness + cpi + industry_share + pop_dens_log + year +
as.factor(country),
data = data)
#-------------------------------------------------------------------------------
# Retransformation - See Rittman et al. (2023)
#-------------------------------------------------------------------------------
install_github("mneunhoe/simloglm")
# Function to sample from inverse gamma distribution
rinvgamma <- function(n, shape, rate = 1, scale = 1/rate){
if(missing(rate) && !missing(scale))
rate <- 1/scale
1/stats::rgamma(n, shape, rate)
}
# Set up informal posterior of coefficients
nsim <- 1000 # number of draws
beta_hat_w <- coef(m1_re_wb_fe)
sigma_hat_w <- summary(m1_re_wb_fe)$sigma
X_prime_X_w <- summary(m1_re_wb_fe)$cov.unscaled
# First sigma^2
set.seed(199610)
sigma2_tilde_w <- rinvgamma(nsim,
shape = m1_re_wb_fe$df.residual/2,
rate = (sigma_hat_w^2*m1_re_wb_fe$df.residual)/2)
# Now the betas
beta_tilde_w <- matrix(NA,
nrow = nsim,
ncol = length(beta_hat_w))
for(sim in 1:nsim){
beta_tilde_w[sim, ] <-
MASS::mvrnorm(1, beta_hat_w, X_prime_X_w * sigma2_tilde_w[sim])
}
#-------------------------------------------------------------------------------
# Set scenarios
#-------------------------------------------------------------------------------
# what's the maximal within-country range of economic inequality?
range_top10 <- aggregate(data$top10,
by = list(data$country),
FUN = range)
names(range_top10) <- c("country", "range")
# get the difference
range_top10$diff <- range_top10$range[,2]- range_top10$range[,1]
# get the respective country
max_range_country <- range_top10$country[which.max(range_top10$diff)]
# and the respective values (min and max > used for setting the scenario)
min_maldives <- range_top10$range[,1][which.max(range_top10$diff)]
max_maldives <- range_top10$range[,2][which.max(range_top10$diff)]
# Find min and max random country intercept (could be relevant for FD)
which.min(summary(m1_re_wb_fe)$coefficients[11:nrow(summary(m1_re_wb_fe)$coefficients),1]) ## Singapore (123)
which.max(summary(m1_re_wb_fe)$coefficients[11:nrow(summary(m1_re_wb_fe)$coefficients),1]) ## Niger (102)
# run once with reference category (i.e. alphabetically first country)
length_coefs <- length(coefficients(m1_re_wb_fe)[which(names(coefficients(m1_re_wb_fe)) %like% "as.factor")]) ## 155
coef_countries_ref <- t(rep(0,length_coefs))
# run once with min
coef_countries_min <- t(c(rep(0,122), 1, rep(0,32)))
# run once with max
coef_countries_max <- t(c(rep(0,101), 1, rep(0,53)))
# To make sure the means are sample-specific!
data_scen <- data[which(data$top10 %in% m1_re_wb_fe$model$top10 &
data$year <= 2020 &
data$year >= 2000 &
!is.na(data$industry_share) &
!is.na(data$`2_gdp_pc_log`) &
!is.na(data$top10) &
!is.na(data$cpi) &
!is.na(data$trade_openness) &
!is.na(data$pop_dens_log) &
!is.na(data$demeaned_winning)),]
scen_1_min_w_ref <- cbind(1,
min_maldives,
mean(data_scen$`2_gdp_pc_log`, na.rm = T),
mean(data_scen$`2_gdp_pc_log_sq`, na.rm = T),
mean(data_scen$W4, na.rm = T),
mean(data_scen$trade_openness, na.rm = T),
mean(data_scen$cpi, na.rm = T),
mean(data_scen$industry_share, na.rm = T),
mean(data_scen$pop_dens_log, na.rm = T),
mean(data_scen$year, na.rm = T),
coef_countries_ref)
# colnames
colnames(scen_1_min_w_ref) <- names(coef(m1_re_wb_fe))
# copy existing scenario1 into new object scenario2
scen_1_max_w_ref <- scen_1_min_w_ref
scen_1_min_w_min <- scen_1_min_w_ref
scen_1_min_w_max <- scen_1_min_w_ref
scen_1_max_w_min <- scen_1_min_w_ref
scen_1_max_w_max <- scen_1_min_w_ref
# switch only the changing values to get scenario with max inequ
scen_1_max_w_ref[, which(colnames(scen_1_max_w_ref) == "top10")] <- max_maldives
scen_1_min_w_min[, which(colnames(scen_1_min_w_min) == "as.factor(country)Singapore")] <- 1
scen_1_max_w_min[, which(colnames(scen_1_max_w_min) == "top10")] <- max_maldives
scen_1_max_w_min[, which(colnames(scen_1_max_w_min) == "as.factor(country)Singapore")] <- 1
scen_1_min_w_max[, which(colnames(scen_1_min_w_max) == "as.factor(country)Niger")] <- 1
scen_1_max_w_max[, which(colnames(scen_1_max_w_max) == "top10")] <- max_maldives
scen_1_max_w_max[, which(colnames(scen_1_max_w_max) == "as.factor(country)Niger")] <- 1
#-------------------------------------------------------------------------------
# Sample-specific means (understandable scenario)
#-------------------------------------------------------------------------------
min_maldives                             ## 0.39
max_maldives                             ## 0.58
mean(exp(data_scen$`2_gdp_pc_log`))      ## 13392
mean(data_scen$W4, na.rm = T)            ## 0.72
mean(data_scen$trade_openness)           ## 0.85
mean(data_scen$cpi, na.rm = T)           ## 4.30
mean(data_scen$industry_share, na.rm =T) ## 0.28
mean(exp(data_scen$pop_dens_log))        ## 189
mean(data_scen$year, na.rm = T)          ## 2011
X_c_w_ref <- rbind(scen_1_max_w_ref, scen_1_min_w_ref)
X_c_w_min <- rbind(scen_1_max_w_min, scen_1_min_w_min)
X_c_w_max <- rbind(scen_1_max_w_max, scen_1_min_w_max)
# Calculate the linear predictor on log scale
X_beta_w_ref <- beta_tilde_w %*% t(X_c_w_ref)
X_beta_w_min <- beta_tilde_w %*% t(X_c_w_min)
X_beta_w_max <- beta_tilde_w %*% t(X_c_w_max)
# Now transform back to original scale
# First add draws of 1/2*sigma2_tilde to each column
X_beta_sigma_tilde_w_ref <- apply(X_beta_w_ref, 2, function(x) x + 1/2*sigma2_tilde_w)
X_beta_sigma_tilde_w_min <- apply(X_beta_w_min, 2, function(x) x + 1/2*sigma2_tilde_w)
X_beta_sigma_tilde_w_max <- apply(X_beta_w_max, 2, function(x) x + 1/2*sigma2_tilde_w)
# Transform
E_Y_c_w_ref <- exp(X_beta_sigma_tilde_w_ref)
E_Y_c_w_min <- exp(X_beta_sigma_tilde_w_min)
E_Y_c_w_max <- exp(X_beta_sigma_tilde_w_max)
# Summarize to get CIs
CI_E_Y_c_w_ref <- apply(E_Y_c_w_ref, 2, quantile, c(0.025, 0.975))
CI_E_Y_c_w_min <- apply(E_Y_c_w_min, 2, quantile, c(0.025, 0.975))
CI_E_Y_c_w_max <- apply(E_Y_c_w_max, 2, quantile, c(0.025, 0.975))
# Use beta_hat and sigma_hat for point estimates
X_beta_hat_w_ref <- beta_hat_w %*% t(X_c_w_ref)
X_beta_hat_w_min <- beta_hat_w %*% t(X_c_w_min)
X_beta_hat_w_max <- beta_hat_w %*% t(X_c_w_max)
X_beta_sigma_hat_w_ref <- X_beta_hat_w_ref + 1/2*sigma_hat_w^2
X_beta_sigma_hat_w_min <- X_beta_hat_w_min + 1/2*sigma_hat_w^2
X_beta_sigma_hat_w_max <- X_beta_hat_w_max + 1/2*sigma_hat_w^2
# Point estimate
E_Y_c_hat_w_ref <- exp(X_beta_sigma_hat_w_ref)
E_Y_c_hat_w_min <- exp(X_beta_sigma_hat_w_min)
E_Y_c_hat_w_max <- exp(X_beta_sigma_hat_w_max)
# First difference
FD_max_min_hat_w_ref <- E_Y_c_hat_w_ref[,1] - E_Y_c_hat_w_ref[,2]
FD_max_min_hat_w_min <- E_Y_c_hat_w_min[,1] - E_Y_c_hat_w_min[,2]
FD_max_min_hat_w_max <- E_Y_c_hat_w_max[,1] - E_Y_c_hat_w_max[,2]
FD_max_min_w_ref <- E_Y_c_w_ref[,1] - E_Y_c_w_ref[,2]
FD_max_min_w_min <- E_Y_c_w_min[,1] - E_Y_c_w_min[,2]
FD_max_min_w_max <- E_Y_c_w_max[,1] - E_Y_c_w_max[,2]
CI_FD_max_min_w_ref <- quantile(FD_max_min_w_ref, c(0.025, 0.975))
CI_FD_max_min_w_min <- quantile(FD_max_min_w_min, c(0.025, 0.975))
CI_FD_max_min_w_max <- quantile(FD_max_min_w_max, c(0.025, 0.975))
#-------------------------------------------------------------------------------
# How "big" is the first difference compared to the SD of the DV (within)?
#-------------------------------------------------------------------------------
## Calculate demeaned
means_pm25 <- aggregate(data_scen$lead_PM25,
by = list(data_scen$country),
FUN = mean, na.rm = T)
## rename
names(means_pm25) <- c("country", "mean")
## put them back into the data frame
data_scen$mean_pm25 <- means_pm25$mean[match(data_scen$country, means_pm25$country)]
## calculate de-meaned variable:
data_scen$demeaned_pm25 <- data_scen$PM25_pop_weighed - data_scen$mean_pm25
## calculate within SD
sd_pm25_w <- sd(data_scen$demeaned_pm25)
## how does FD compare to SD?
share_fd_sd_w_ref <- abs(FD_max_min_hat_w_ref)/sd_pm25_w
share_fd_sd_w_min <- abs(FD_max_min_hat_w_min)/sd_pm25_w
share_fd_sd_w_max <- abs(FD_max_min_hat_w_max)/sd_pm25_w
share_fd_sd_w_ref
share_fd_sd_w_max
share_fd_sd_w_min
plot(density(E_Y_c_w_ref[,1]),
bty = "n",
xlim = c(13,21),
main = NA,
las = 1,
ylim = c(0,1.01),
yaxt = "n",
cex = 1.1,
cex.lab = 1.3,
xlab = expression("Exposure to PM"[2.5]*" ["*mu~"g/m"^3*"]"),
type = "n")
polygon(density(E_Y_c_w_ref[,1]),
col = viridis(3, alpha = 0.4)[1],
border = F,
main = NULL)
polygon(density(E_Y_c_w_ref[,2]),
col = viridis(3, alpha = 0.4)[2],
border = F,
main = NULL)
lines(density(E_Y_c_w_ref[,1]),
col = viridis(3)[1])
lines(density(E_Y_c_w_ref[,2]),
col = viridis(3)[2])
abline(v = c(E_Y_c_hat_w_ref[,1],
E_Y_c_hat_w_ref[,2]),
lty = 2, lwd = 2,
col = c(viridis(3)[1],
viridis(3)[2]))
legend("topleft",
title = "Albania",
# title.cex = 1.3,
legend = c("Max. Top 10%-Share",
"Min. Top 10%-Share"),
col = c(viridis(3, alpha = 0.5)[1],
viridis(3, alpha = 0.5)[2]),
pch = 19,
cex = 1.1,
bty = "n")
plot(density(E_Y_c_w_min[,1]),
bty = "n",
#xlim = c(4.8,8.5),
main = NA,
las = 1,
ylim = c(0,1.6),
yaxt = "n",
cex = 1.1,
cex.lab = 1.3,
xlab = expression("Exposure to PM"[2.5]*" ["*mu~"g/m"^3*"]"),
type = "n")
polygon(density(E_Y_c_w_min[,1]),
col = viridis(3, alpha = 0.4)[1],
border = F,
main = NULL)
polygon(density(E_Y_c_w_min[,2]),
col = viridis(3, alpha = 0.4)[2],
border = F,
main = NULL)
lines(density(E_Y_c_w_min[,1]),
col = viridis(3)[1])
lines(density(E_Y_c_w_min[,2]),
col = viridis(3)[2])
abline(v = c(E_Y_c_hat_w_min[,1],
E_Y_c_hat_w_min[,2]),
lty = 2, lwd = 2,
col = c(viridis(3)[1],
viridis(3)[2]))
legend("topleft",
title = "Singapore",
# title.cex = 1.3,
legend = c("Max. Top 10%-Share",
"Min. Top 10%-Share"),
col = c(viridis(3, alpha = 0.5)[1],
viridis(3, alpha = 0.5)[2]),
pch = 19,
cex = 1.1,
bty = "n")
plot(density(E_Y_c_w_max[,1]),
bty = "n",
#  xlim = c(60,110),
main = NA,
las = 1,
ylim = c(0,0.07),
yaxt = "n",
cex = 1.1,
cex.lab = 1.3,
xlab = expression("Exposure to PM"[2.5]*" ["*mu~"g/m"^3*"]"),
type = "n")
polygon(density(E_Y_c_w_max[,1]),
col = viridis(3, alpha = 0.4)[1],
border = F,
main = NULL)
polygon(density(E_Y_c_w_max[,2]),
col = viridis(3, alpha = 0.4)[2],
border = F,
main = NULL)
lines(density(E_Y_c_w_max[,1]),
col = viridis(3)[1])
lines(density(E_Y_c_w_max[,2]),
col = viridis(3)[2])
abline(v = c(E_Y_c_hat_w_max[,1],
E_Y_c_hat_w_max[,2]),
lty = 2, lwd = 2,
col = c(viridis(3)[1],
viridis(3)[2]))
legend("topleft",
title = "Niger",
# title.cex = 1.3,
legend = c("Max. Top 10%-Share",
"Min. Top 10%-Share"),
col = c(viridis(3, alpha = 0.5)[1],
viridis(3, alpha = 0.5)[2]),
pch = 19,
cex = 1.1,
bty = "n")
plot(y = 1,
x = FD_max_min_hat_w_ref,
col = viridis(3)[1],
ylim = c(0,2),
xlim = c(-15,0.5),
xlab = "",
pch = 19,
main = NULL,
bty = "n",
ylab = "",
yaxt = "n",
cex = 3,
cex.lab = 1.1)
## ref
segments(y0 = 1, x0 = CI_FD_max_min_w_ref[1],
y1 = 1, x1 = CI_FD_max_min_w_ref[2],
col = viridis(3, alpha = 0.4)[1],
lwd = 12, cex = 1.5, lend = 1)
segments(x0 = 0, y0 = 0,
x1 = 0, y1 = 2,
lty = "dashed", lwd = 2)
## min
points(y = 1.5,
x = FD_max_min_hat_w_min,
col = viridis(3)[1],
pch = 19,
cex = 3)
segments(y0 = 1.5, x0 = CI_FD_max_min_w_min[1],
y1 = 1.5, x1 = CI_FD_max_min_w_min[2],
col = viridis(3, alpha = 0.4)[1],
lwd = 12, cex = 1.5, lend = 1)
## max
points(y = 0.5,
x = FD_max_min_hat_w_max,
col = viridis(3)[1],
pch = 19,
cex = 3)
segments(y0 = 0.5, x0 = CI_FD_max_min_w_max[1],
y1 = 0.5, x1 = CI_FD_max_min_w_max[2],
col = viridis(3, alpha = 0.4)[1],
lwd = 12, cex = 1.5, lend = 1)
text(x = FD_max_min_hat_w_max,
y = 0.2,
labels = c("First Difference"),
cex = 1.3)
text(x = FD_max_min_hat_w_max,
y = 0.1,
labels = c("(Max - Min)"),
cex = 0.9)
text(x = -12,
y = 0.5,
labels = c("Niger"),
cex = 0.9)
text(x = -3,
y = 1,
labels = c("Albania (Ref. cat.)"),
cex = 0.9)
text(x = -1.6,
y = 1.5,
labels = c("Singapore"),
cex = 0.9)
mean(data$PM25_pop_weighed[which(data$country == "Niger")], na.rm=T)
